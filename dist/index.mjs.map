{"version":3,"sources":["../src/lib/wallet.ts","../src/lib/helpers.ts","../src/lib/masternode-api.ts","../src/lib/encoder.ts","../src/lib/transaction-builder.ts","../src/lib/keystore.ts","../src/index.ts"],"sourcesContent":["import * as helpers from \"./helpers\";\nimport nacl from \"tweetnacl\";\nimport * as bip39 from \"bip39\";\nimport { HDKey } from \"ed25519-keygen/hdkey\";\n\n/**\n * Create a wallet object for signing and verifying messages\n *\n * @param {Object} [args={}] Args Object\n * @param {string} [args.sk=undefined] A 32 character long hex representation of a signing key (private key) to create wallet from\n * @param {Uint8Array(length: 32)} [args.seed=null] A Uint8Array with a length of 32 to seed the keyPair with. This is advanced behavior and should be avoided by everyday users\n * @param {boolean} [args.keepPrivate=false] No direct access to the sk. Will still allow the wallet to sign messages\n * @return {Object} Wallet Object with sign and verify methods\n */\nexport let create_wallet = (args: any = {}) => {\n  let { sk, keepPrivate, seed } = args;\n  let vk;\n\n  if (sk) {\n    vk = get_vk(sk);\n  } else {\n    let keyPair = new_wallet(seed);\n    vk = keyPair.vk;\n    sk = keyPair.sk;\n  }\n\n  const wallet = () => {\n    return {\n      sign: (msg) => sign(sk, msg),\n      verify: (msg, sig) => verify(vk, msg, sig),\n      vk,\n      sk: !keepPrivate ? sk : undefined,\n    };\n  };\n\n  return wallet();\n};\n\n/**\n * @param Uint8Array(length: 32) seed\n *      seed:   A Uint8Array with a length of 32 to seed the keyPair with. This is advanced behavior and should be\n *              avoided by everyday users\n *\n * @return {Uint8Array(length: 32), Uint8Array(length: 32)} { vk, sk }\n *      sk:     Signing Key (SK) represents 32 byte signing key\n *      vk:     Verify Key (VK) represents a 32 byte verify key\n */\nexport function generate_keys(seed = null) {\n  var kp = null;\n  if (seed == null) {\n    kp = nacl.sign.keyPair();\n  } else {\n    kp = nacl.sign.keyPair.fromSeed(seed);\n  }\n  // In the JS implementation of the NaCL library the sk is the first 32 bytes of the secretKey\n  // and the vk is the last 32 bytes of the secretKey as well as the publicKey\n  // {\n  //   'publicKey': <vk>,\n  //   'secretKey': <sk><vk>\n  // }\n  return {\n    sk: new Uint8Array(kp[\"secretKey\"].slice(0, 32)),\n    vk: new Uint8Array(kp[\"secretKey\"].slice(32, 64)),\n  };\n}\n/**\n * @param String sk\n *      sk:     A 64 character long hex representation of a signing key (private key)\n *\n * @return String vk\n *      vk:     A 64 character long hex representation of a verify key (public key)\n */\nexport function get_vk(sk) {\n  var kp = format_to_keys(sk);\n  var kpf = keys_to_format(kp);\n  return kpf.vk;\n}\n/**\n * @param String sk\n *      sk:     A 64 character long hex representation of a signing key (private key)\n *\n * @return {Uint8Array(length: 32), Uint8Array(length: 32)} { vk, sk }\n *      sk:     Signing Key (SK) represents 32 byte signing key\n *      vk:     Verify Key (VK) represents a 32 byte verify key\n */\nexport function format_to_keys(sk) {\n  var skf = helpers.hex2buf(sk);\n  var kp = generate_keys(skf);\n  return kp;\n}\n/**\n * @param Object kp\n *      kp:     Object containing the properties sk and vk\n *          sk:     Signing Key (SK) represents 32 byte signing key\n *          vk:     Verify Key (VK) represents a 32 byte verify key\n *\n * @return {string, string} { sk, vk }\n *      sk:     Signing Key (SK) represented as a 64 character hex string\n *      vk:     Verify Key (VK) represented as a 64 character hex string\n */\nexport function keys_to_format(kp) {\n  return {\n    vk: helpers.buf2hex(kp.vk),\n    sk: helpers.buf2hex(kp.sk),\n  };\n}\n/**\n * @param Uint8Array(length: 32) seed\n *      seed:   A Uint8Array with a length of 32 to seed the keyPair with. This is advanced behavior and should be\n *              avoided by everyday users\n *\n * @return {string, string} { sk, vk }\n *      sk:     Signing Key (SK) represented as a 64 character hex string\n *      vk:     Verify Key (VK) represented as a 64 character hex string\n */\nexport function new_wallet(seed = null) {\n  const keys = generate_keys(seed);\n  return keys_to_format(keys);\n}\n\n/**\n *\n * @param seed Bip39 seed phrase (128 characters in hex)\n * @param derivationIndex bip32 derivation key index\n * @returns {{derivationIndex: number, vk: string, sk: string, mnemonic: string}}\n *      derivationIndex:    bip32 derivation key index\n *      vk:                 Verify Key (VK) represented as a 64 character hex string\n *      sk:                 Signing Key (SK) represented as a 64 character hex string\n *      seed:               Bip39 seed phrase (128 characters in hex)\n *      mnemonic:           Bip39 24 words mnemonic\n */\nfunction generate_keys_bip39(seed = undefined, derivationIndex = 0) {\n  let finalSeed;\n  let finalMnemonic;\n\n  if (seed !== undefined) {\n    finalSeed = seed;\n  } else {\n    finalMnemonic = bip39.generateMnemonic(256);\n    finalSeed = bip39.mnemonicToSeedSync(finalMnemonic).toString(\"hex\");\n  }\n\n  let hdkey = HDKey.fromMasterSeed(finalSeed);\n  const derivationPath = \"m/44'/789'/\" + derivationIndex + \"'/0'/0'\";\n  hdkey = hdkey.derive(derivationPath);\n  const privateKey = helpers.buf2hex(hdkey.privateKey);\n  const publicKey = helpers.buf2hex(hdkey.publicKey).slice(2);\n\n  if (publicKey !== get_vk(privateKey)) {\n    throw Error(\"Bip32 public key does not match with Lamden public key!\");\n  }\n\n  if (finalMnemonic !== undefined) {\n  }\n\n  return {\n    sk: privateKey,\n    vk: publicKey,\n    derivationIndex: derivationIndex,\n    seed: seed !== undefined ? null : finalSeed,\n    mnemonic: seed !== undefined ? null : finalMnemonic,\n  };\n}\n\n/**\n * @param seed Bip39 seed phrase (128 characters in hex)\n * @param derivationIndex bip32 derivation key index\n *\n * @return {{derivationIndex: number, vk: string, sk: string, mnemonic: (string|undefined)}} { sk, vk, derivationIndex, mnemonic }\n *      sk:                 Signing Key (SK) represented as a 64 character hex string\n *      vk:                 Verify Key (VK) represented as a 64 character hex string\n *      derivationIndex:    Bip32 derivation index\n *      seed:               Bip39 seed phrase (128 characters in hex)\n *      mnemonic:           Bip39 24 words mnemonic\n */\nexport function new_wallet_bip39(seed = undefined, derivationIndex = 0) {\n  return generate_keys_bip39(seed, derivationIndex);\n}\n\n/**\n * @param String sk\n * @param Uint8Array msg\n *      sk:     A 64 character long hex representation of a signing key (private key)\n *      msg:    A Uint8Array of bytes representing the message you would like to sign\n *\n * @return String sig\n *      sig:    A 128 character long hex string representing the message's signature\n */\nexport function sign(sk: string, msg: Uint8Array): string {\n  var kp = format_to_keys(sk);\n  // This is required due to the secretKey required to sign a transaction\n  // in the js implementation of NaCL being the combination of the sk and\n  // vk for some stupid reason. That being said, we still want the sk and\n  // vk objects to exist in 32-byte string format (same as cilantro's\n  // python implementation) when presented to the user.\n  var jsnacl_sk = helpers.concatUint8Arrays(kp.sk, kp.vk);\n  return helpers.buf2hex(nacl.sign.detached(msg, jsnacl_sk));\n}\n/**\n * @param String vk\n * @param {(Uint8Array|string)} msg\n * @param String sig\n *      vk:     A 64 character long hex representation of a verify key (public key)\n *      msg:    A Uint8Array (bytes) || (string) representation of a message that has been signed\n *      sig:    A 128 character long hex representation of a nacl signature\n *\n * @return Bool result\n *      result: true if verify checked out, false if not\n */\nexport function verify(vk, msg, sig) {\n  var vkb = helpers.hex2buf(vk);\n  var sigb = helpers.hex2buf(sig);\n  var msgb = msg;\n\n  // Convert string messages to Uint8Array\n  if (Object.prototype.toString.call(msgb) === \"[object String]\")\n    msgb = helpers.str2buf(msg);\n\n  try {\n    return nacl.sign.detached.verify(msgb, sigb, vkb);\n  } catch (_a) {\n    return false;\n  }\n}\n/**\n * @param string mnemonic\n * @param string[] wordList\n *      mnemonic: Bip39 24 words mnemonic\n *      wordList: An array of string(Optional)\n *\n * @return Boolen res\n *      res: A boolen value\n */\nexport function validateMnemonic(mnemonic, wordList) {\n  return bip39.validateMnemonic(mnemonic, wordList);\n}\n","import nodeCryptoJs from \"node-cryptojs-aes\";\nconst { CryptoJS, JsonFormatter } = nodeCryptoJs;\nimport { I_Payload, I_PayloadSorted, I_Transaction, T_QueryResponseDataType } from \"../types\";\n\n/**\n * Encrypt a Javascript object with a string password\n * The object passed must pass JSON.stringify or the method will fail.\n *\n * @param {string} password  A password to encrypt the object with\n * @param {Object} obj A javascript object (must be JSON compatible)\n * @return {string} Encrypted string\n */\nexport function encryptObject(password: string, obj: object) {\n\tif (typeof password !== \"string\" || password === \"\") {\n\t\tthrow new Error(\"Password must be a non-empty string\");\n\t}\n\tif (typeof obj !== \"object\" || obj === null) {\n\t\tthrow new Error(\"Object must be a non-null object\");\n\t}\n\n\tconst encrypted = CryptoJS.AES.encrypt(JSON.stringify(obj), password, {\n\t\tformat: JsonFormatter\n\t}).toString();\n\treturn encrypted;\n}\n\n/**\n *  Decrypt an Object using a password string\n *\n *  @param {string} password  A password to encrypt the object with\n *  @param {string} objString A javascript object as JSON string\n *  @return {string} Encrypted string\n */\nexport function decryptObject(password: string, objString: string) {\n\tif (typeof password !== \"string\" || password === \"\") {\n\t\tthrow new Error(\"Password must be a non-empty string\");\n\t}\n\tif (typeof objString !== \"string\" || objString === \"\") {\n\t\tthrow new Error(\"Object string must be a non-empty string\");\n\t}\n\n\ttry {\n\t\tconst decrypt = CryptoJS.AES.decrypt(objString, password, { format: JsonFormatter });\n\t\treturn JSON.parse(CryptoJS.enc.Utf8.stringify(decrypt));\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n/**\n * Encrypt a string using a password string\n *\n * @param {string} password  A password to encrypt the object with\n * @param {string} string A string to be password encrypted\n * @return {string} Encrypted string\n */\nexport function encryptStrHash(password, string) {\n\tif (typeof password !== \"string\" || password === \"\") {\n\t\tthrow new Error(\"Password must be a non-empty string\");\n\t}\n\tif (typeof string !== \"string\") {\n\t\tthrow new Error(\"String must be a non-empty string\");\n\t}\n\tconst encrypt = CryptoJS.AES.encrypt(string, password).toString();\n\treturn encrypt;\n}\n\n/**\n * Decrypt a string using a password string\n *\n * @param {string} password  A password to encrypt the object with\n * @param {string} encryptedString A string to decrypt\n * @return {string} Decrypted string\n */\nexport function decryptStrHash(password, encryptedString) {\n\tif (typeof password !== \"string\" || password === \"\") {\n\t\tthrow new Error(\"Password must be a non-empty string\");\n\t}\n\tif (typeof encryptedString !== \"string\" || encryptedString === \"\") {\n\t\tthrow new Error(\"Encrypted string must be a non-empty string\");\n\t}\n\n\ttry {\n\t\tconst decrypted = CryptoJS.AES.decrypt(encryptedString, password);\n\t\treturn CryptoJS.enc.Utf8.stringify(decrypted) === \"\" ? false : CryptoJS.enc.Utf8.stringify(decrypted);\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nexport function buf2hex(buffer) {\n\treturn Array.prototype.map.call(new Uint8Array(buffer), (x) => (\"00\" + x.toString(16)).slice(-2)).join(\"\");\n}\nexport function hex2buf(hexString) {\n\tvar bytes = new Uint8Array(Math.ceil(hexString.length / 2));\n\tfor (var i = 0; i < bytes.length; i++) bytes[i] = parseInt(hexString.substr(i * 2, 2), 16);\n\treturn bytes;\n}\nexport function str2buf(string) {\n\tvar buf = Buffer.from(string);\n\treturn new Uint8Array(buf);\n}\nexport function concatUint8Arrays(array1, array2) {\n\tvar arr = new Uint8Array(array1.length + array2.length);\n\tarr.set(array1);\n\tarr.set(array2, array1.length);\n\treturn arr;\n}\nexport function ab2str(buf) {\n\treturn String.fromCharCode.apply(null, new Uint8Array(buf));\n}\nexport function str2ab(str) {\n\tvar buf = new ArrayBuffer(str.length);\n\tvar bufView = new Uint8Array(buf);\n\tfor (var i = 0, strLen = str.length; i < strLen; i++) {\n\t\tbufView[i] = str.charCodeAt(i);\n\t}\n\treturn buf;\n}\nexport function str2hex(str) {\n\tvar hex = \"\";\n\tfor (var i = 0; i < str.length; i++) {\n\t\thex += \"\" + str.charCodeAt(i).toString(16);\n\t}\n\treturn hex;\n}\nexport function hex2str(hexx) {\n\tvar hex = hexx.toString(); //force conversion\n\tvar str = \"\";\n\tfor (var i = 0; i < hex.length && hex.substr(i, 2) !== \"00\"; i += 2) str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));\n\treturn str;\n}\nexport function randomString(length) {\n\tvar text = \"\";\n\tvar possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\tfor (var i = 0; i < length; i++) {\n\t\ttext += possible.charAt(Math.floor(Math.random() * possible.length));\n\t}\n\treturn text;\n}\nexport function isStringHex(string = \"\") {\n\tlet hexRegEx = /([0-9]|[a-f])/gim;\n\treturn typeof string === \"string\" && (string.match(hexRegEx) || []).length === string.length;\n}\n\nexport function isLamdenKey(string) {\n\tif (/^[0-9a-fA-F]{64}$/.test(string)) return true;\n\treturn false;\n}\n\nexport function decodeInt(encodedInt) {\n\tlet decodedBytes = Buffer.from(encodedInt, \"base64\");\n\tlet value = decodedBytes.readInt32BE(0);\n\treturn value;\n}\n\nexport function decodeQuery(response: any) {\n\tlet value: number | string | null;\n\tlet type: T_QueryResponseDataType = response.info;\n\tif (type === \"int\") {\n\t\tvalue = parseInt(Buffer.from(response.value, \"base64\").toString());\n\t} else if (type === \"decimal\") {\n\t\tvalue = parseFloat(Buffer.from(response.value, \"base64\").toString());\n\t} else if (type === \"str\") {\n\t\tvalue = Buffer.from(response.value, \"base64\").toString();\n\t} else {\n\t\tvalue = null;\n\t}\n\n\treturn value;\n}\n\nexport function decodeStr(encodedStr) {\n\tlet decodedBytes = Buffer.from(encodedStr, \"base64\");\n\tlet value = decodedBytes.toString();\n\treturn value;\n}\n\nexport function decodeObj(encodedObj: string) {\n\tlet decodedBytes = Buffer.from(encodedObj, \"base64\");\n\tlet value = JSON.parse(decodedBytes.toString());\n\treturn value;\n}\n\nexport function sortObject(object: I_Payload): I_PayloadSorted {\n\tconst orderedPayload = processObj(object) as I_Payload;\n\treturn {\n\t\torderedPayload: orderedPayload,\n\t\tjsonData: JSON.stringify(orderedPayload)\n\t};\n}\n\nexport function sortObjKeys(unsorted) {\n\tconst sorted = {};\n\tObject.keys(unsorted)\n\t\t.sort()\n\t\t.forEach((key) => (sorted[key] = unsorted[key]));\n\treturn sorted;\n}\n\nfunction processObj(obj) {\n\tif (!isObject(obj)) throw new TypeError(\"Not a valid Object\");\n\ttry {\n\t\tobj = JSON.parse(JSON.stringify(obj));\n\t} catch (e) {\n\t\tthrow new TypeError(\"Not a valid JSON Object\");\n\t}\n\treturn formatKeys(obj);\n}\n\nfunction formatKeys(unformatted: object) {\n\tObject.keys(unformatted).forEach((key) => {\n\t\tif (isArray(unformatted[key]))\n\t\t\tunformatted[key] = unformatted[key].map((item) => {\n\t\t\t\tif (isObject(item)) return formatKeys(item);\n\t\t\t\treturn item;\n\t\t\t});\n\t\tif (isObject(unformatted[key])) unformatted[key] = formatKeys(unformatted[key]);\n\t});\n\treturn sortObjKeys(unformatted);\n}\n\nfunction isArray(value) {\n\tif (getType(value) === \"[object Array]\") return true;\n\treturn false;\n}\nconst isObject = (value) => {\n\tif (getType(value) === \"[object Object]\") return true;\n\treturn false;\n};\n\nfunction getType(value: any) {\n\treturn Object.prototype.toString.call(value);\n}\n\nexport function makePayload(payload_args: I_Payload) {\n\treturn sortObject(payload_args);\n}\n\nexport function makeTransaction(signature: string, sortedPayload: I_PayloadSorted): I_Transaction {\n\treturn {\n\t\tmetadata: {\n\t\t\tsignature: signature\n\t\t},\n\t\tpayload: sortedPayload.orderedPayload\n\t};\n}\n\nexport function verifySignature(payload: I_PayloadSorted, wallet, signature: string) {\n\tconst stringBuffer = Buffer.from(payload.jsonData);\n\tconst stringArray = new Uint8Array(stringBuffer);\n\treturn wallet.verify(this.sender, stringArray, this.signature);\n}\n\nexport const stringifyTransaction = (tx: object) => Buffer.from(JSON.stringify(tx)).toString(\"hex\");\n","import axios from \"axios\";\nimport { decodeInt, decodeObj, decodeQuery, decodeStr, stringifyTransaction } from \"./helpers\";\nimport { I_BroadcastTxResult, I_NetworkSettings, I_SendTxResult, I_Transaction } from \"../types\";\nimport { Encoder } from \"./encoder\";\n\nexport class MasternodeAPI {\n\thosts: string[];\n\n\tconstructor(network_settings: I_NetworkSettings) {\n\t\tif (typeof network_settings !== \"object\" || Object.keys(network_settings).length === 0)\n\t\t\tthrow new Error(`Expected Object and got Type: ${typeof network_settings}`);\n\t\tif (!Array.isArray(network_settings.masternode_hosts) || network_settings.masternode_hosts.length === 0)\n\t\t\tthrow new Error(`HOSTS Required (Type: Array)`);\n\t\tthis.hosts = this.validateHosts(network_settings.masternode_hosts);\n\t}\n\n\tvalidateProtocol(host: string) {\n\t\tlet protocols = [\"https://\", \"http://\"];\n\t\tif (protocols.map((protocol) => host.includes(protocol)).includes(true)) return host;\n\t\tthrow new Error(\"Host String must include http:// or https://\");\n\t}\n\n\tvalidateHosts(hosts: string[]) {\n\t\treturn hosts.map((host) => this.validateProtocol(host.toLowerCase()));\n\t}\n\n\tget host() {\n\t\treturn this.hosts[Math.floor(Math.random() * this.hosts.length)];\n\t}\n\n\tget url() {\n\t\treturn this.host;\n\t}\n\n\tasync getContractInfo(contractName: string) {\n\t\tconst { data } = await axios.post(`${this.host}/abci_query?path=\"/contract/${contractName}\"`);\n\t\treturn decodeQuery(data.result.response);\n\t}\n\n\tasync getVariable(contract: string, variable: string) {\n\t\tlet path = `/get/${contract}.${variable}/`;\n\t\tconst url = `${this.host}/abci_query?path=\"${path}\"`;\n\t\tconst { data } = await axios.post(url);\n\t\tconst result = data.result.response;\n\t\tlet decoded = decodeQuery(result);\n\t\treturn decoded;\n\t}\n\n\tasync getContractMethods(contractName) {\n\t\tconst { data } = await axios.post(`${this.host}/abci_query?path=\"/contract_methods/${contractName}\"`);\n\t\treturn JSON.parse(decodeQuery(data.result.response) as string);\n\t}\n\n\tasync getContractVariables(contractName) {\n\t\tconst { data } = await axios.post(`${this.host}/abci_query?path=\"/contract_vars/${contractName}\"`);\n\t\treturn JSON.parse(decodeQuery(data.result.response) as string);\n\t}\n\n\tasync pingServer() {\n\t\tconst { data } = await axios.post(`${this.host}/abci_query?path=\"/ping/\"`);\n\t\treturn JSON.parse(decodeQuery(data.result.response) as string);\n\t}\n\n\tasync getCurrencyBalance(vk: string) {\n\t\tlet balanceRes = await this.getVariable(\"currency\", `balances:${vk}`);\n\t\tif (!balanceRes) return Encoder(\"bigNumber\", 0);\n\t\tif (balanceRes) return Encoder(\"bigNumber\", balanceRes);\n\t\treturn Encoder(\"bigNumber\", balanceRes.toString());\n\t}\n\n\tasync contractExists(contractName) {\n\t\tconst contract = await this.getContractInfo(contractName);\n\t\tif (contract) return true;\n\t\treturn false;\n\t}\n\n\tasync broadcastTx(tx: I_Transaction): Promise<I_SendTxResult> {\n\t\tconst txString = stringifyTransaction(tx);\n\t\tconst url = `${this.host}/broadcast_tx_commit?tx=\"${txString}\"`;\n\t\tconst { data } = await axios.get(url);\n\t\tconst { check_tx, deliver_tx, hash } = data.result as I_BroadcastTxResult;\n\t\tconst result_data = deliver_tx.data ? decodeObj(deliver_tx.data) : null;\n\t\tconst check = check_tx.code === 0;\n\t\tconst deliver = deliver_tx.code === 0;\n\t\treturn { success: check && deliver, data: result_data, hash };\n\t}\n\n\tasync getNonce(vk: string) {\n\t\tconst path = `/abci_query?path=\"/get_next_nonce/${vk}\"`;\n\t\tconst url = `${this.host}${path}`;\n\t\tconst { data } = await axios.post(url);\n\t\tconst value = data.result.response.value;\n\t\tif (value === \"AA==\") return 0;\n\t\tconst decoded = decodeInt(value);\n\t\treturn decoded;\n\t}\n\n\tgetTransaction(hash: string) {\n\t\treturn axios.get(`${this.host}/tx?hash=\"0x${hash}\"`);\n\t}\n\n\tgetNodeInfo() {\n\t\treturn axios.get(`${this.host}/status`);\n\t}\n\n\tasync getLastetBlock() {\n\t\treturn axios.get(`${this.host}/block`);\n\t}\n}\n","import BigNumber from \"bignumber.js\";\nBigNumber.config({ RANGE: [-30, 30], EXPONENTIAL_AT: 1e9 });\nBigNumber.set({ DECIMAL_PLACES: 30, ROUNDING_MODE: BigNumber.ROUND_DOWN }); // equivalent\n\nexport function Encoder(type: string, value: any) {\n\tconst throwError = (val) => {\n\t\tthrow new Error(`Error encoding ${val} to ${type}`);\n\t};\n\tconst countDecimals = (n) => {\n\t\tif (Math.floor(n) === n) return 0;\n\t\ttry {\n\t\t\treturn n.toString().split(\".\")[1].length;\n\t\t} catch (e) {\n\t\t\treturn 0;\n\t\t}\n\t};\n\tconst isString = (val) => typeof val === \"string\" || val instanceof String;\n\tconst isArray = (val) => val && typeof val === \"object\" && val.constructor === Array;\n\tconst isObject = (val) => val && typeof val === \"object\" && val.constructor === Object;\n\tconst isDate = (val) => val instanceof Date;\n\tconst isBoolean = (val) => typeof val === \"boolean\";\n\n\tconst isNumber = (val) => {\n\t\tif (isArray(val)) return false;\n\t\treturn !isNaN(encodeBigNumber(val).toNumber());\n\t};\n\n\tconst isInteger = (val) => {\n\t\tif (!isNumber(val)) return false;\n\t\tif (countDecimals(val) === 0) return true;\n\t\treturn false;\n\t};\n\tconst encodeInt = (val) => {\n\t\tif (!isNumber(val)) throwError(val);\n\t\telse return parseInt(val);\n\t};\n\tconst isFloat = (val) => {\n\t\tif (!isNumber(val)) return false;\n\t\tif (countDecimals(val) === 0) return false;\n\t\treturn true;\n\t};\n\tconst encodeFloat = (val) => {\n\t\tif (!isNumber(val)) throwError(val);\n\t\tif (!BigNumber.isBigNumber(val)) val = new BigNumber(val);\n\n\t\treturn { __fixed__: val.toFixed(30).replace(/^0+(\\d)|(\\d)0+$/gm, \"$1$2\") };\n\t};\n\tconst encodeNumber = (val) => {\n\t\tif (!isNumber(val)) throwError(val);\n\t\tif (isFloat(val)) {\n\t\t\tif (!BigNumber.isBigNumber(val)) val = new BigNumber(val);\n\t\t\treturn { __fixed__: val.toFixed(30).replace(/^0+(\\d)|(\\d)0+$/gm, \"$1$2\") };\n\t\t}\n\t\tif (isInteger(val)) return parseInt(val);\n\t};\n\tconst encodeBigNumber = (val) => {\n\t\tif (!BigNumber.isBigNumber(val)) val = new BigNumber(val);\n\t\treturn val;\n\t};\n\n\tconst encodeBool = (val) => {\n\t\tif (isBoolean(val)) return val;\n\t\tif (val === \"true\" || val === 1) return true;\n\t\tif (val === \"false\" || val === 0) return false;\n\t\tthrowError(val);\n\t};\n\tconst encodeStr = (val) => {\n\t\tif (isString(val)) return val;\n\t\tif (isDate(val)) return val.toISOString();\n\t\treturn JSON.stringify(val);\n\t};\n\tconst encodeDateTime = (val) => {\n\t\tval = !isDate(val) ? new Date(val) : val;\n\t\tif (!isDate(val)) throwError(val);\n\t\treturn {\n\t\t\t__time__: [\n\t\t\t\tval.getUTCFullYear(),\n\t\t\t\tval.getUTCMonth(),\n\t\t\t\tval.getUTCDate(),\n\t\t\t\tval.getUTCHours(),\n\t\t\t\tval.getUTCMinutes(),\n\t\t\t\tval.getUTCSeconds(),\n\t\t\t\tval.getUTCMilliseconds()\n\t\t\t]\n\t\t};\n\t};\n\tconst encodeTimeDelta = (val) => {\n\t\tconst time: number = isDate(val) ? val.getTime() : new Date(val).getTime();\n\t\tconst days = time / 1000 / 60 / 60 / 24;\n\t\tconst seconds = (time - days * 24 * 60 * 60 * 1000) / 1000;\n\t\treturn { __delta__: [days, seconds] };\n\t};\n\n\tconst encodeList = (val: any) => {\n\t\tif (isArray(val)) return parseObject(val);\n\t\ttry {\n\t\t\tval = JSON.parse(val);\n\t\t} catch (e) {\n\t\t\tthrowError(val);\n\t\t}\n\t\tif (isArray(val)) return parseObject(val);\n\t\tthrowError(val);\n\t};\n\n\tconst encodeDict = (val) => {\n\t\tif (isObject(val)) return parseObject(val);\n\t\ttry {\n\t\t\tval = JSON.parse(val);\n\t\t} catch (e) {\n\t\t\tthrowError(val);\n\t\t}\n\t\tif (isObject(val)) return parseObject(val);\n\t\tthrowError(val);\n\t};\n\n\tconst encodeObject = (val) => {\n\t\ttry {\n\t\t\treturn encodeList(val);\n\t\t} catch (e) {\n\t\t\treturn encodeDict(val);\n\t\t}\n\t};\n\n\tfunction parseObject(obj) {\n\t\tconst encode = (k, v) => {\n\t\t\tif (k === \"datetime\" || k === \"datetime.datetime\") return Encoder(\"datetime.datetime\", v);\n\t\t\tif (k === \"timedelta\" || k === \"datetime.timedelta\") return Encoder(\"datetime.timedelta\", v);\n\t\t\tif (k !== \"__fixed__\" && isFloat(v)) return encodeFloat(v);\n\t\t\treturn v;\n\t\t};\n\n\t\tconst fixDatetime = (k, v) => {\n\t\t\tconst isDatetimeObject = (val) => {\n\t\t\t\tlet datetimeTypes = [\"datetime.datetime\", \"datetime\", \"datetime.timedelta\", \"timedelta\"];\n\t\t\t\treturn Object.keys(val).length === 1 && datetimeTypes.filter((f) => f === Object.keys(val)[0]).length > 0;\n\t\t\t};\n\n\t\t\tif (v.constructor === Array) {\n\t\t\t\tv.map((val) => {\n\t\t\t\t\tif (Object.keys(val).length === 1 && isDatetimeObject(v)) return val[Object.keys(val)[0]];\n\t\t\t\t\t//if (isFloat(val)) return encodeFloat(val)\n\t\t\t\t\treturn val;\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (v.constructor === Object) {\n\t\t\t\tif (Object.keys(v).length === 1 && isDatetimeObject(v)) return v[Object.keys(v)[0]];\n\t\t\t}\n\n\t\t\t//if (isFloat(v)) return encodeFloat(v)\n\n\t\t\treturn v;\n\t\t};\n\n\t\tlet encodeValues = JSON.stringify(obj, encode);\n\t\treturn JSON.parse(encodeValues, fixDatetime);\n\t}\n\n\tconst encoder = {\n\t\tstr: encodeStr,\n\t\tstring: encodeStr,\n\t\tfloat: encodeFloat,\n\t\tint: encodeInt,\n\t\tbool: encodeBool,\n\t\tboolean: encodeBool,\n\t\tdict: encodeDict,\n\t\tlist: encodeList,\n\t\tAny: () => value,\n\t\t\"datetime.timedelta\": encodeTimeDelta,\n\t\t\"datetime.datetime\": encodeDateTime,\n\t\ttimedelta: encodeTimeDelta,\n\t\tdatetime: encodeDateTime,\n\t\tnumber: encodeNumber,\n\t\tobject: encodeObject,\n\t\tbigNumber: encodeBigNumber\n\t};\n\n\tif (Object.keys(encoder).includes(type)) return encoder[type](value);\n\telse throw new Error(`Error: ${type} is not a valid encoder type.`);\n}\n\nEncoder.BigNumber = BigNumber;\n\nexport default { Encoder };\n","import * as wallet from \"./wallet\";\nimport { makePayload, makeTransaction } from \"./helpers\";\nimport { I_NetworkSettings, I_Payload, I_PayloadSorted, I_SendTxResult, I_TxInfo } from \"../types\";\nimport { MasternodeAPI } from \"./masternode-api\";\n\nexport class TransactionBuilder {\n\tuid: string;\n\tsender: string;\n\tcontract: string;\n\tmethod: string;\n\tkwargs: object = {};\n\tstampLimit: number;\n\tnonce: number;\n\tsignature: string;\n\ttransactionSigned: boolean = false;\n\ttxSendResult: { errors: string[] } = { errors: [] };\n\ttxBlockResult: object = {};\n\ttxHash: string;\n\tchain_id: string;\n\tpayload: I_Payload;\n\tsortedPayload: I_PayloadSorted;\n\tmasternodeApi: MasternodeAPI;\n\n\tconstructor(networkSettings: I_NetworkSettings, txInfo: I_TxInfo) {\n\t\t/**\n\t\t * Validate Data\n\t\t */\n\n\t\tif (typeof txInfo !== \"object\" || Object.keys(txInfo).length === 0) throw new Error(`txInfo object not found`);\n\t\tif (typeof txInfo.senderVk !== \"string\" || !/^[0-9a-fA-F]+$/.test(txInfo.senderVk))\n\t\t\tthrow new Error(`Sender Public Key Required (Type: Hex String)`);\n\t\tif (typeof txInfo.contractName !== \"string\" || txInfo.contractName.trim() === \"\")\n\t\t\tthrow new Error(`Contract Name Required (Type: String)`);\n\t\tif (typeof txInfo.methodName !== \"string\" || txInfo.methodName.trim() === \"\") throw new Error(`Method Required (Type: String)`);\n\t\tif (typeof txInfo.stampLimit !== \"number\" || !Number.isInteger(txInfo.stampLimit))\n\t\t\tthrow new Error(`Stamps Limit Required (Type: Integer)`);\n\t\tif (txInfo.nonce) {\n\t\t\tif (!Number.isInteger(txInfo.nonce))\n\t\t\t\tthrow new Error(`arg[6] Nonce is required to be an Integer, type ${typeof txInfo.nonce} was given`);\n\t\t\tthis.nonce = txInfo.nonce;\n\t\t}\n\n\t\t/**\n\t\t * Define Variables\n\t\t */\n\n\t\tthis.sender = txInfo.senderVk;\n\t\tthis.masternodeApi = new MasternodeAPI(networkSettings);\n\t\tthis.contract = txInfo.contractName;\n\t\tthis.method = txInfo.methodName;\n\t\tif (typeof txInfo.kwargs === \"object\") {\n\t\t\tthis.kwargs = txInfo.kwargs;\n\t\t}\n\t\tthis.stampLimit = txInfo.stampLimit;\n\t\tthis.chain_id = networkSettings.chain_id;\n\n\t\tthis.payload = {\n\t\t\tsender: txInfo.senderVk,\n\t\t\tcontract: txInfo.contractName,\n\t\t\tfunction: txInfo.methodName,\n\t\t\tkwargs: txInfo.kwargs,\n\t\t\tstamps_supplied: txInfo.stampLimit,\n\t\t\tchain_id: txInfo.chain_id,\n\t\t\tnonce: txInfo.nonce ? txInfo.nonce : undefined // user may set the nonce manually.\n\t\t};\n\t}\n\n\tprivate sign(sk: string, sortedPayload: I_PayloadSorted) {\n\t\tconst stringBuffer = Buffer.from(sortedPayload.jsonData);\n\t\tconst stringArray = new Uint8Array(stringBuffer);\n\t\treturn wallet.sign(sk, stringArray);\n\t}\n\n\tpublic async send(sk: string): Promise<I_SendTxResult> {\n\t\ttry {\n\t\t\t// If the user didn't supply a nonce, get one from a node.\n\t\t\tif (!this.payload.nonce) {\n\t\t\t\tthis.payload.nonce = await this.masternodeApi.getNonce(this.sender);\n\t\t\t}\n\t\t\tthis.sortedPayload = makePayload(this.payload);\n\t\t\t// Sign the transaction\n\t\t\tconst signature = this.sign(sk, this.sortedPayload);\n\t\t\t//Serialize transaction\n\t\t\tconst tx = makeTransaction(signature, this.sortedPayload);\n\t\t\t//Send transaction to the masternode\n\t\t\tlet response = await this.masternodeApi.broadcastTx(tx);\n\t\t\treturn response;\n\t\t} catch (e) {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: e\n\t\t\t};\n\t\t}\n\t}\n}\n","import * as helpers from './helpers';\nimport * as wallet from './wallet'\n\nexport class Keystore {\n    KEYSTORE_VERSION: string;\n    password: string;\n    encryptedData: any;\n    keyList: any;\n    version: any;\n    /**\n     * Lamden Keystores\n     *\n     * This Class will create a lamden keystore instance\n     *\n     * @param {Object|undefined} arg constructor argument\n     * @param {String|undefined} arg.key Create an instance and load it with one private key\n     * @param {String|undefined} arg.keyList Create an instance and load it with an array of private keys\n     * @param {String|undefined} arg.keystoreData Create an instance from an existing keystore file data\n     * @return {Keystore}\n     */\n    constructor(arg = undefined) {\n        this.KEYSTORE_VERSION = \"1.0\"\n        this.password = null\n        this.encryptedData = null;\n\n        this.keyList = (() => {\n            let keyList = []\n            let outerClass = this\n            let wallets = []\n\n            const addKey = (key) => {\n                keyList.push(key)\n                createWallets()\n            }\n            const deleteKey = (position) => {\n                keyList.splice(position, 1);\n                createWallets()\n            }\n            const clearKeys = () => {\n                keyList = []\n                createWallets()\n            }\n            const numOfKeys = () => keyList.length\n            const createWallets = () => {\n                wallets = []\n                keyList.forEach(keyInfo => {\n                    let newWallet = wallet.create_wallet({sk: keyInfo.sk, keepPrivate: true})\n                    newWallet = {...newWallet, ...keyInfo}\n                    delete newWallet.sk\n                    wallets.push(newWallet)\n                })\n            }\n            const createKeystore = (password, hint = undefined) => {\n                return JSON.stringify({\n                    data: helpers.encryptObject(password, {version: outerClass.KEYSTORE_VERSION, keyList}),\n                    w: !hint ? \"\" : helpers.encryptStrHash('n1ahcKc0lb', hint),\n                });\n            }\n            const decryptKeystore = (password, data) => {\n                let decrypted = helpers.decryptObject(password, data)\n                if (decrypted) {\n                    if (!Array.isArray(decrypted.keyList)) {\n                        throw new Error(\"Invalid keyList format. Expected an array.\");\n                    }\n                    decrypted.keyList.forEach(keyInfo => {\n                        if (typeof keyInfo.sk !== 'string' || keyInfo.sk.trim() === '') {\n                            throw new Error(\"Invalid private key format. Expected a non-empty string.\");\n                        }\n                    });\n                    decrypted.keyList.forEach(keyInfo => addKey(keyInfo))\n                    outerClass.version = decrypted.version\n                } else {\n                    throw new Error(\"Incorrect Keystore Password.\")\n                }\n            }\n\n            return {\n                getWallets: () => wallets,\n                getWallet: (vk) => wallets.find(wallet => wallet.vk === vk),\n                addKey, \n                clearKeys, \n                numOfKeys,\n                deleteKey,\n                createKeystore,\n                decryptKeystore\n            }\n        })()\n\n        if (arg){\n            if (arg.key) this.addKey(arg.key)\n            if (arg.keyList) this.addKeys(arg.keyList)\n            if (arg.keystoreData) this.addKeystoreData(arg.keystoreData)\n        }\n    }\n    /**\n     * Add a list of keys to add to the keystore\n     * @typedef {Object} keyinfo\n     * @property {string} sk - The private key. \n     * @property {string} nickname - The key nickname. \n     * @property {string} name - The key name.\n     * @property {string} network - Network name. \n     * @property {string} symbol - The token symbol.\n     * @param {Array.<keyinfo>} keyList An array of keyinfo Object\n     */\n    addKeys(keyList){\n        if (!Array.isArray(keyList)) {\n            throw new Error(\"keyList must be an array.\");\n        }\n        keyList.forEach(key => this.addKey(key));\n    }\n    /**\n     * Add a key to the keystore\n     * @typedef {Object} keyinfo\n     * @property {string} sk - The private key. \n     * @property {string} nickname - The key nickname. \n     * @property {string} name - The key name.\n     * @property {string} network - Network name. \n     * @property {string} symbol - The token symbol.\n     * @param {keyinfo} keyInfo A keyinfo Object \n     */\n    addKey(keyInfo){\n        if (typeof keyInfo !== 'object' || Object.keys(keyInfo).length === 0) {\n            throw new Error(\"keyInfo must be an object with keys.\");\n        }\n        if (typeof keyInfo.sk !== 'string' || keyInfo.sk.trim() === '') {\n            throw new Error(\"Private key (sk) must be a non-empty string.\");\n        }\n        if (typeof keyInfo.vk === 'string' && keyInfo.vk.trim() !== '') {\n            delete keyInfo.vk;\n        }\n        this.keyList.addKey(keyInfo)\n    }\n    /**\n     * Load the keystore with the data from an existing keystore\n     * @param {string} keystoreData The contents of an existing encrypted keystore file\n     */\n    addKeystoreData(keystoreData){\n        if (typeof keystoreData === 'string') keystoreData = JSON.parse(keystoreData);\n        if (typeof this.validateKeyStore === 'function' && this.validateKeyStore(keystoreData)) {\n            this.encryptedData = keystoreData\n        }\n    }\n    /**\n     * Returns the password hint in a keystore file\n     * @param {String|undefined} keystoreData The contents of an existing encrypted keystore file if one wasn't supplied to the constructor\n     */\n    getPasswordHint(keystoreData = undefined){\n        if (!this.encryptedData && !keystoreData) throw new Error(\"No keystore data found.\")\n\n        if (keystoreData)  {\n            if (typeof keystoreData === 'string')  keystoreData = JSON.parse(keystoreData)\n        }\n        else keystoreData = this.encryptedData\n\n        if (keystoreData.w) return helpers.decryptStrHash('n1ahcKc0lb', keystoreData.w);\n        else return \"\"\n    }\n    /**\n     * Removes a specific key from the keyList\n     * @param {Number} keyIndex The index of the key you want to remove\n     */\n    deleteKey(keyIndex){\n        if (!Number.isInteger(keyIndex)) {\n            throw new Error(\"Key index must be an integer.\");\n        }\n        if (this.keyList.numOfKeys() === 0) return;\n        if (keyIndex < 0 || keyIndex >= this.keyList.numOfKeys()) throw new Error(\"Key index out of range.\")\n        this.keyList.deleteKey(keyIndex)\n    }\n    /**\n     * Clears all keys from the keystore\n     */\n    clearKeys(){\n        this.keyList.clearKeys()\n    }\n    /**\n     * Clears all keys from the keystore\n     * @return {Array.<Object>} An array of wallet objects\n     */\n    get wallets() {\n        return this.keyList.getWallets()\n    }\n    /**\n     * Load the keystore with the data from an existing keystore\n     * @param {String} vk A 32 character long Lamden public key\n     * @return {Object} A wallet object\n     */\n    getWallet(vk) {\n        return this.keyList.getWallet(vk)\n    }\n    /**\n     * Used to validate that a keystore is the proper Lamden Format (does not decrypt data)\n     * @param {String} keystoreData The contents of an existing encrypted keystore file\n     * @return {Boolean} valid\n     * @throws {Error} This is not a valid keystore file.\n     */\n    validateKeyStore(keystoreData){\n        if (typeof keystoreData !== 'object' || Object.keys(keystoreData).length === 0) {\n            throw new Error(\"Keystore data must be an object with keys.\");\n        }\n        try{\n            let encryptedData = JSON.parse(keystoreData.data);\n             if (!encryptedData.ct || !encryptedData.iv || !encryptedData.s){\n                throw new Error(\"This is not a valid keystore file.\")\n            }\n        } catch (e) {\n            throw new Error(\"This is not a valid keystore file.\")\n        }\n        return true;\n    }\n    /**\n     * Create a Keystore text string from the keys contained in the Keystore instance\n     * @param {String} password A password to encrypt the data\n     * @param {String|undefined} hint An optional password hint. Not stored in clear text (obsured) but not encrypted with the password.\n     * @return {String} A JSON stringified object containing the encrypted data\n     * @throws {Error} Any errors from the encyption process\n     */\n    createKeystore(password, hint = undefined) {\n        if (typeof password !== 'string' || password.trim() === '') {\n            throw new Error(\"Password must be a non-empty string.\");\n        }\n        if (hint && (typeof hint !== 'string' || hint.trim() === '')) {\n            throw new Error(\"Hint must be a non-empty string.\");\n        }\n        return this.keyList.createKeystore(password, hint)\n    }\n    /**\n     * Decrypt a keystore into a useable array of wallets.  Any decrypted keys will be added to existing keys in the keystore.\n     * @param {String} password A password to encrypt the data\n     * @param {String|undefined} keystoreData The encrypted contents from a keystore file if not passed into the constructor.\n     * @throws {Error} Any errors from the encyption process\n     */\n    decryptKeystore(password, keystoreData = undefined){\n        if (keystoreData) this.addKeystoreData(keystoreData)\n        if (!this.encryptedData) throw new Error (\"No keystoreData to decrypt.\")\n        try{\n            this.keyList.decryptKeystore(password, this.encryptedData.data)\n        }catch (e){\n            throw new Error(\"Incorrect Keystore Password.\")\n        }\n    }\n}\n","import { TransactionBuilder } from \"./lib/transaction-builder\";\nimport { Encoder } from \"./lib/encoder\";\nimport { Keystore } from \"./lib/keystore\";\nimport { MasternodeAPI } from \"./lib/masternode-api\";\nimport * as Wallet from \"./lib/wallet\";\nimport * as Utils from \"./lib/helpers\";\nimport { Buffer } from \"buffer\";\n\nglobalThis.Buffer = Buffer;\n\nexport {\n\tTransactionBuilder,\n\tMasternodeAPI,\n\tWallet,\n\tKeystore,\n\tEncoder,\n\tUtils\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0BAAAA;AAAA,EAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAO,kBAAkB;AACzB,IAAM,EAAE,UAAU,cAAc,IAAI;AAW7B,SAAS,cAAc,UAAkB,KAAa;AAC5D,MAAI,OAAO,aAAa,YAAY,aAAa,IAAI;AACpD,UAAM,IAAI,MAAM,qCAAqC;AAAA,EACtD;AACA,MAAI,OAAO,QAAQ,YAAY,QAAQ,MAAM;AAC5C,UAAM,IAAI,MAAM,kCAAkC;AAAA,EACnD;AAEA,QAAM,YAAY,SAAS,IAAI,QAAQ,KAAK,UAAU,GAAG,GAAG,UAAU;AAAA,IACrE,QAAQ;AAAA,EACT,CAAC,EAAE,SAAS;AACZ,SAAO;AACR;AASO,SAAS,cAAc,UAAkB,WAAmB;AAClE,MAAI,OAAO,aAAa,YAAY,aAAa,IAAI;AACpD,UAAM,IAAI,MAAM,qCAAqC;AAAA,EACtD;AACA,MAAI,OAAO,cAAc,YAAY,cAAc,IAAI;AACtD,UAAM,IAAI,MAAM,0CAA0C;AAAA,EAC3D;AAEA,MAAI;AACH,UAAM,UAAU,SAAS,IAAI,QAAQ,WAAW,UAAU,EAAE,QAAQ,cAAc,CAAC;AACnF,WAAO,KAAK,MAAM,SAAS,IAAI,KAAK,UAAU,OAAO,CAAC;AAAA,EACvD,SAAS,GAAG;AACX,WAAO;AAAA,EACR;AACD;AASO,SAAS,eAAe,UAAU,QAAQ;AAChD,MAAI,OAAO,aAAa,YAAY,aAAa,IAAI;AACpD,UAAM,IAAI,MAAM,qCAAqC;AAAA,EACtD;AACA,MAAI,OAAO,WAAW,UAAU;AAC/B,UAAM,IAAI,MAAM,mCAAmC;AAAA,EACpD;AACA,QAAM,UAAU,SAAS,IAAI,QAAQ,QAAQ,QAAQ,EAAE,SAAS;AAChE,SAAO;AACR;AASO,SAAS,eAAe,UAAU,iBAAiB;AACzD,MAAI,OAAO,aAAa,YAAY,aAAa,IAAI;AACpD,UAAM,IAAI,MAAM,qCAAqC;AAAA,EACtD;AACA,MAAI,OAAO,oBAAoB,YAAY,oBAAoB,IAAI;AAClE,UAAM,IAAI,MAAM,6CAA6C;AAAA,EAC9D;AAEA,MAAI;AACH,UAAM,YAAY,SAAS,IAAI,QAAQ,iBAAiB,QAAQ;AAChE,WAAO,SAAS,IAAI,KAAK,UAAU,SAAS,MAAM,KAAK,QAAQ,SAAS,IAAI,KAAK,UAAU,SAAS;AAAA,EACrG,SAAS,GAAG;AACX,WAAO;AAAA,EACR;AACD;AAEO,SAAS,QAAQ,QAAQ;AAC/B,SAAO,MAAM,UAAU,IAAI,KAAK,IAAI,WAAW,MAAM,GAAG,CAAC,OAAO,OAAO,EAAE,SAAS,EAAE,GAAG,MAAM,EAAE,CAAC,EAAE,KAAK,EAAE;AAC1G;AACO,SAAS,QAAQ,WAAW;AAClC,MAAI,QAAQ,IAAI,WAAW,KAAK,KAAK,UAAU,SAAS,CAAC,CAAC;AAC1D,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ;AAAK,UAAM,CAAC,IAAI,SAAS,UAAU,OAAO,IAAI,GAAG,CAAC,GAAG,EAAE;AACzF,SAAO;AACR;AACO,SAAS,QAAQ,QAAQ;AAC/B,MAAI,MAAM,OAAO,KAAK,MAAM;AAC5B,SAAO,IAAI,WAAW,GAAG;AAC1B;AACO,SAAS,kBAAkB,QAAQ,QAAQ;AACjD,MAAI,MAAM,IAAI,WAAW,OAAO,SAAS,OAAO,MAAM;AACtD,MAAI,IAAI,MAAM;AACd,MAAI,IAAI,QAAQ,OAAO,MAAM;AAC7B,SAAO;AACR;AACO,SAAS,OAAO,KAAK;AAC3B,SAAO,OAAO,aAAa,MAAM,MAAM,IAAI,WAAW,GAAG,CAAC;AAC3D;AACO,SAAS,OAAO,KAAK;AAC3B,MAAI,MAAM,IAAI,YAAY,IAAI,MAAM;AACpC,MAAI,UAAU,IAAI,WAAW,GAAG;AAChC,WAAS,IAAI,GAAG,SAAS,IAAI,QAAQ,IAAI,QAAQ,KAAK;AACrD,YAAQ,CAAC,IAAI,IAAI,WAAW,CAAC;AAAA,EAC9B;AACA,SAAO;AACR;AACO,SAAS,QAAQ,KAAK;AAC5B,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACpC,WAAO,KAAK,IAAI,WAAW,CAAC,EAAE,SAAS,EAAE;AAAA,EAC1C;AACA,SAAO;AACR;AACO,SAAS,QAAQ,MAAM;AAC7B,MAAI,MAAM,KAAK,SAAS;AACxB,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,IAAI,UAAU,IAAI,OAAO,GAAG,CAAC,MAAM,MAAM,KAAK;AAAG,WAAO,OAAO,aAAa,SAAS,IAAI,OAAO,GAAG,CAAC,GAAG,EAAE,CAAC;AAC9H,SAAO;AACR;AACO,SAAS,aAAa,QAAQ;AACpC,MAAI,OAAO;AACX,MAAI,WAAW;AACf,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,YAAQ,SAAS,OAAO,KAAK,MAAM,KAAK,OAAO,IAAI,SAAS,MAAM,CAAC;AAAA,EACpE;AACA,SAAO;AACR;AACO,SAAS,YAAY,SAAS,IAAI;AACxC,MAAI,WAAW;AACf,SAAO,OAAO,WAAW,aAAa,OAAO,MAAM,QAAQ,KAAK,CAAC,GAAG,WAAW,OAAO;AACvF;AAEO,SAAS,YAAY,QAAQ;AACnC,MAAI,oBAAoB,KAAK,MAAM;AAAG,WAAO;AAC7C,SAAO;AACR;AAEO,SAAS,UAAU,YAAY;AACrC,MAAI,eAAe,OAAO,KAAK,YAAY,QAAQ;AACnD,MAAI,QAAQ,aAAa,YAAY,CAAC;AACtC,SAAO;AACR;AAEO,SAAS,YAAY,UAAe;AAC1C,MAAI;AACJ,MAAI,OAAgC,SAAS;AAC7C,MAAI,SAAS,OAAO;AACnB,YAAQ,SAAS,OAAO,KAAK,SAAS,OAAO,QAAQ,EAAE,SAAS,CAAC;AAAA,EAClE,WAAW,SAAS,WAAW;AAC9B,YAAQ,WAAW,OAAO,KAAK,SAAS,OAAO,QAAQ,EAAE,SAAS,CAAC;AAAA,EACpE,WAAW,SAAS,OAAO;AAC1B,YAAQ,OAAO,KAAK,SAAS,OAAO,QAAQ,EAAE,SAAS;AAAA,EACxD,OAAO;AACN,YAAQ;AAAA,EACT;AAEA,SAAO;AACR;AAEO,SAAS,UAAU,YAAY;AACrC,MAAI,eAAe,OAAO,KAAK,YAAY,QAAQ;AACnD,MAAI,QAAQ,aAAa,SAAS;AAClC,SAAO;AACR;AAEO,SAAS,UAAU,YAAoB;AAC7C,MAAI,eAAe,OAAO,KAAK,YAAY,QAAQ;AACnD,MAAI,QAAQ,KAAK,MAAM,aAAa,SAAS,CAAC;AAC9C,SAAO;AACR;AAEO,SAAS,WAAW,QAAoC;AAC9D,QAAM,iBAAiB,WAAW,MAAM;AACxC,SAAO;AAAA,IACN;AAAA,IACA,UAAU,KAAK,UAAU,cAAc;AAAA,EACxC;AACD;AAEO,SAAS,YAAY,UAAU;AACrC,QAAM,SAAS,CAAC;AAChB,SAAO,KAAK,QAAQ,EAClB,KAAK,EACL,QAAQ,CAAC,QAAS,OAAO,GAAG,IAAI,SAAS,GAAG,CAAE;AAChD,SAAO;AACR;AAEA,SAAS,WAAW,KAAK;AACxB,MAAI,CAAC,SAAS,GAAG;AAAG,UAAM,IAAI,UAAU,oBAAoB;AAC5D,MAAI;AACH,UAAM,KAAK,MAAM,KAAK,UAAU,GAAG,CAAC;AAAA,EACrC,SAAS,GAAG;AACX,UAAM,IAAI,UAAU,yBAAyB;AAAA,EAC9C;AACA,SAAO,WAAW,GAAG;AACtB;AAEA,SAAS,WAAW,aAAqB;AACxC,SAAO,KAAK,WAAW,EAAE,QAAQ,CAAC,QAAQ;AACzC,QAAI,QAAQ,YAAY,GAAG,CAAC;AAC3B,kBAAY,GAAG,IAAI,YAAY,GAAG,EAAE,IAAI,CAAC,SAAS;AACjD,YAAI,SAAS,IAAI;AAAG,iBAAO,WAAW,IAAI;AAC1C,eAAO;AAAA,MACR,CAAC;AACF,QAAI,SAAS,YAAY,GAAG,CAAC;AAAG,kBAAY,GAAG,IAAI,WAAW,YAAY,GAAG,CAAC;AAAA,EAC/E,CAAC;AACD,SAAO,YAAY,WAAW;AAC/B;AAEA,SAAS,QAAQ,OAAO;AACvB,MAAI,QAAQ,KAAK,MAAM;AAAkB,WAAO;AAChD,SAAO;AACR;AACA,IAAM,WAAW,CAAC,UAAU;AAC3B,MAAI,QAAQ,KAAK,MAAM;AAAmB,WAAO;AACjD,SAAO;AACR;AAEA,SAAS,QAAQ,OAAY;AAC5B,SAAO,OAAO,UAAU,SAAS,KAAK,KAAK;AAC5C;AAEO,SAAS,YAAY,cAAyB;AACpD,SAAO,WAAW,YAAY;AAC/B;AAEO,SAAS,gBAAgB,WAAmB,eAA+C;AACjG,SAAO;AAAA,IACN,UAAU;AAAA,MACT;AAAA,IACD;AAAA,IACA,SAAS,cAAc;AAAA,EACxB;AACD;AAEO,SAAS,gBAAgB,SAA0B,QAAQ,WAAmB;AACpF,QAAM,eAAe,OAAO,KAAK,QAAQ,QAAQ;AACjD,QAAM,cAAc,IAAI,WAAW,YAAY;AAC/C,SAAO,OAAO,OAAO,KAAK,QAAQ,aAAa,KAAK,SAAS;AAC9D;AAEO,IAAM,uBAAuB,CAAC,OAAe,OAAO,KAAK,KAAK,UAAU,EAAE,CAAC,EAAE,SAAS,KAAK;;;AD7PlG,OAAO,UAAU;AACjB,YAAY,WAAW;AACvB,SAAS,aAAa;AAWf,IAAI,gBAAgB,CAAC,OAAY,CAAC,MAAM;AAC7C,MAAI,EAAE,IAAI,aAAa,KAAK,IAAI;AAChC,MAAI;AAEJ,MAAI,IAAI;AACN,SAAK,OAAO,EAAE;AAAA,EAChB,OAAO;AACL,QAAI,UAAU,WAAW,IAAI;AAC7B,SAAK,QAAQ;AACb,SAAK,QAAQ;AAAA,EACf;AAEA,QAAM,SAAS,MAAM;AACnB,WAAO;AAAA,MACL,MAAM,CAAC,QAAQ,KAAK,IAAI,GAAG;AAAA,MAC3B,QAAQ,CAAC,KAAK,QAAQ,OAAO,IAAI,KAAK,GAAG;AAAA,MACzC;AAAA,MACA,IAAI,CAAC,cAAc,KAAK;AAAA,IAC1B;AAAA,EACF;AAEA,SAAO,OAAO;AAChB;AAWO,SAAS,cAAc,OAAO,MAAM;AACzC,MAAI,KAAK;AACT,MAAI,QAAQ,MAAM;AAChB,SAAK,KAAK,KAAK,QAAQ;AAAA,EACzB,OAAO;AACL,SAAK,KAAK,KAAK,QAAQ,SAAS,IAAI;AAAA,EACtC;AAOA,SAAO;AAAA,IACL,IAAI,IAAI,WAAW,GAAG,WAAW,EAAE,MAAM,GAAG,EAAE,CAAC;AAAA,IAC/C,IAAI,IAAI,WAAW,GAAG,WAAW,EAAE,MAAM,IAAI,EAAE,CAAC;AAAA,EAClD;AACF;AAQO,SAAS,OAAO,IAAI;AACzB,MAAI,KAAK,eAAe,EAAE;AAC1B,MAAI,MAAM,eAAe,EAAE;AAC3B,SAAO,IAAI;AACb;AASO,SAAS,eAAe,IAAI;AACjC,MAAI,MAAc,QAAQ,EAAE;AAC5B,MAAI,KAAK,cAAc,GAAG;AAC1B,SAAO;AACT;AAWO,SAAS,eAAe,IAAI;AACjC,SAAO;AAAA,IACL,IAAY,QAAQ,GAAG,EAAE;AAAA,IACzB,IAAY,QAAQ,GAAG,EAAE;AAAA,EAC3B;AACF;AAUO,SAAS,WAAW,OAAO,MAAM;AACtC,QAAM,OAAO,cAAc,IAAI;AAC/B,SAAO,eAAe,IAAI;AAC5B;AAaA,SAAS,oBAAoB,OAAO,QAAW,kBAAkB,GAAG;AAClE,MAAI;AACJ,MAAI;AAEJ,MAAI,SAAS,QAAW;AACtB,gBAAY;AAAA,EACd,OAAO;AACL,oBAAsB,uBAAiB,GAAG;AAC1C,gBAAkB,yBAAmB,aAAa,EAAE,SAAS,KAAK;AAAA,EACpE;AAEA,MAAI,QAAQ,MAAM,eAAe,SAAS;AAC1C,QAAM,iBAAiB,gBAAgB,kBAAkB;AACzD,UAAQ,MAAM,OAAO,cAAc;AACnC,QAAM,aAAqB,QAAQ,MAAM,UAAU;AACnD,QAAM,YAAoB,QAAQ,MAAM,SAAS,EAAE,MAAM,CAAC;AAE1D,MAAI,cAAc,OAAO,UAAU,GAAG;AACpC,UAAM,MAAM,yDAAyD;AAAA,EACvE;AAEA,MAAI,kBAAkB,QAAW;AAAA,EACjC;AAEA,SAAO;AAAA,IACL,IAAI;AAAA,IACJ,IAAI;AAAA,IACJ;AAAA,IACA,MAAM,SAAS,SAAY,OAAO;AAAA,IAClC,UAAU,SAAS,SAAY,OAAO;AAAA,EACxC;AACF;AAaO,SAAS,iBAAiB,OAAO,QAAW,kBAAkB,GAAG;AACtE,SAAO,oBAAoB,MAAM,eAAe;AAClD;AAWO,SAAS,KAAK,IAAY,KAAyB;AACxD,MAAI,KAAK,eAAe,EAAE;AAM1B,MAAI,YAAoB,kBAAkB,GAAG,IAAI,GAAG,EAAE;AACtD,SAAe,QAAQ,KAAK,KAAK,SAAS,KAAK,SAAS,CAAC;AAC3D;AAYO,SAAS,OAAO,IAAI,KAAK,KAAK;AACnC,MAAI,MAAc,QAAQ,EAAE;AAC5B,MAAI,OAAe,QAAQ,GAAG;AAC9B,MAAI,OAAO;AAGX,MAAI,OAAO,UAAU,SAAS,KAAK,IAAI,MAAM;AAC3C,WAAe,QAAQ,GAAG;AAE5B,MAAI;AACF,WAAO,KAAK,KAAK,SAAS,OAAO,MAAM,MAAM,GAAG;AAAA,EAClD,SAAS,IAAI;AACX,WAAO;AAAA,EACT;AACF;AAUO,SAASC,kBAAiB,UAAU,UAAU;AACnD,SAAa,uBAAiB,UAAU,QAAQ;AAClD;;;AE3OA,OAAO,WAAW;;;ACAlB,OAAO,eAAe;AACtB,UAAU,OAAO,EAAE,OAAO,CAAC,KAAK,EAAE,GAAG,gBAAgB,IAAI,CAAC;AAC1D,UAAU,IAAI,EAAE,gBAAgB,IAAI,eAAe,UAAU,WAAW,CAAC;AAElE,SAAS,QAAQ,MAAc,OAAY;AACjD,QAAM,aAAa,CAAC,QAAQ;AAC3B,UAAM,IAAI,MAAM,kBAAkB,GAAG,OAAO,IAAI,EAAE;AAAA,EACnD;AACA,QAAM,gBAAgB,CAAC,MAAM;AAC5B,QAAI,KAAK,MAAM,CAAC,MAAM;AAAG,aAAO;AAChC,QAAI;AACH,aAAO,EAAE,SAAS,EAAE,MAAM,GAAG,EAAE,CAAC,EAAE;AAAA,IACnC,SAAS,GAAG;AACX,aAAO;AAAA,IACR;AAAA,EACD;AACA,QAAM,WAAW,CAAC,QAAQ,OAAO,QAAQ,YAAY,eAAe;AACpE,QAAMC,WAAU,CAAC,QAAQ,OAAO,OAAO,QAAQ,YAAY,IAAI,gBAAgB;AAC/E,QAAMC,YAAW,CAAC,QAAQ,OAAO,OAAO,QAAQ,YAAY,IAAI,gBAAgB;AAChF,QAAM,SAAS,CAAC,QAAQ,eAAe;AACvC,QAAM,YAAY,CAAC,QAAQ,OAAO,QAAQ;AAE1C,QAAM,WAAW,CAAC,QAAQ;AACzB,QAAID,SAAQ,GAAG;AAAG,aAAO;AACzB,WAAO,CAAC,MAAM,gBAAgB,GAAG,EAAE,SAAS,CAAC;AAAA,EAC9C;AAEA,QAAM,YAAY,CAAC,QAAQ;AAC1B,QAAI,CAAC,SAAS,GAAG;AAAG,aAAO;AAC3B,QAAI,cAAc,GAAG,MAAM;AAAG,aAAO;AACrC,WAAO;AAAA,EACR;AACA,QAAM,YAAY,CAAC,QAAQ;AAC1B,QAAI,CAAC,SAAS,GAAG;AAAG,iBAAW,GAAG;AAAA;AAC7B,aAAO,SAAS,GAAG;AAAA,EACzB;AACA,QAAM,UAAU,CAAC,QAAQ;AACxB,QAAI,CAAC,SAAS,GAAG;AAAG,aAAO;AAC3B,QAAI,cAAc,GAAG,MAAM;AAAG,aAAO;AACrC,WAAO;AAAA,EACR;AACA,QAAM,cAAc,CAAC,QAAQ;AAC5B,QAAI,CAAC,SAAS,GAAG;AAAG,iBAAW,GAAG;AAClC,QAAI,CAAC,UAAU,YAAY,GAAG;AAAG,YAAM,IAAI,UAAU,GAAG;AAExD,WAAO,EAAE,WAAW,IAAI,QAAQ,EAAE,EAAE,QAAQ,qBAAqB,MAAM,EAAE;AAAA,EAC1E;AACA,QAAM,eAAe,CAAC,QAAQ;AAC7B,QAAI,CAAC,SAAS,GAAG;AAAG,iBAAW,GAAG;AAClC,QAAI,QAAQ,GAAG,GAAG;AACjB,UAAI,CAAC,UAAU,YAAY,GAAG;AAAG,cAAM,IAAI,UAAU,GAAG;AACxD,aAAO,EAAE,WAAW,IAAI,QAAQ,EAAE,EAAE,QAAQ,qBAAqB,MAAM,EAAE;AAAA,IAC1E;AACA,QAAI,UAAU,GAAG;AAAG,aAAO,SAAS,GAAG;AAAA,EACxC;AACA,QAAM,kBAAkB,CAAC,QAAQ;AAChC,QAAI,CAAC,UAAU,YAAY,GAAG;AAAG,YAAM,IAAI,UAAU,GAAG;AACxD,WAAO;AAAA,EACR;AAEA,QAAM,aAAa,CAAC,QAAQ;AAC3B,QAAI,UAAU,GAAG;AAAG,aAAO;AAC3B,QAAI,QAAQ,UAAU,QAAQ;AAAG,aAAO;AACxC,QAAI,QAAQ,WAAW,QAAQ;AAAG,aAAO;AACzC,eAAW,GAAG;AAAA,EACf;AACA,QAAM,YAAY,CAAC,QAAQ;AAC1B,QAAI,SAAS,GAAG;AAAG,aAAO;AAC1B,QAAI,OAAO,GAAG;AAAG,aAAO,IAAI,YAAY;AACxC,WAAO,KAAK,UAAU,GAAG;AAAA,EAC1B;AACA,QAAM,iBAAiB,CAAC,QAAQ;AAC/B,UAAM,CAAC,OAAO,GAAG,IAAI,IAAI,KAAK,GAAG,IAAI;AACrC,QAAI,CAAC,OAAO,GAAG;AAAG,iBAAW,GAAG;AAChC,WAAO;AAAA,MACN,UAAU;AAAA,QACT,IAAI,eAAe;AAAA,QACnB,IAAI,YAAY;AAAA,QAChB,IAAI,WAAW;AAAA,QACf,IAAI,YAAY;AAAA,QAChB,IAAI,cAAc;AAAA,QAClB,IAAI,cAAc;AAAA,QAClB,IAAI,mBAAmB;AAAA,MACxB;AAAA,IACD;AAAA,EACD;AACA,QAAM,kBAAkB,CAAC,QAAQ;AAChC,UAAM,OAAe,OAAO,GAAG,IAAI,IAAI,QAAQ,IAAI,IAAI,KAAK,GAAG,EAAE,QAAQ;AACzE,UAAM,OAAO,OAAO,MAAO,KAAK,KAAK;AACrC,UAAM,WAAW,OAAO,OAAO,KAAK,KAAK,KAAK,OAAQ;AACtD,WAAO,EAAE,WAAW,CAAC,MAAM,OAAO,EAAE;AAAA,EACrC;AAEA,QAAM,aAAa,CAAC,QAAa;AAChC,QAAIA,SAAQ,GAAG;AAAG,aAAO,YAAY,GAAG;AACxC,QAAI;AACH,YAAM,KAAK,MAAM,GAAG;AAAA,IACrB,SAAS,GAAG;AACX,iBAAW,GAAG;AAAA,IACf;AACA,QAAIA,SAAQ,GAAG;AAAG,aAAO,YAAY,GAAG;AACxC,eAAW,GAAG;AAAA,EACf;AAEA,QAAM,aAAa,CAAC,QAAQ;AAC3B,QAAIC,UAAS,GAAG;AAAG,aAAO,YAAY,GAAG;AACzC,QAAI;AACH,YAAM,KAAK,MAAM,GAAG;AAAA,IACrB,SAAS,GAAG;AACX,iBAAW,GAAG;AAAA,IACf;AACA,QAAIA,UAAS,GAAG;AAAG,aAAO,YAAY,GAAG;AACzC,eAAW,GAAG;AAAA,EACf;AAEA,QAAM,eAAe,CAAC,QAAQ;AAC7B,QAAI;AACH,aAAO,WAAW,GAAG;AAAA,IACtB,SAAS,GAAG;AACX,aAAO,WAAW,GAAG;AAAA,IACtB;AAAA,EACD;AAEA,WAAS,YAAY,KAAK;AACzB,UAAM,SAAS,CAAC,GAAG,MAAM;AACxB,UAAI,MAAM,cAAc,MAAM;AAAqB,eAAO,QAAQ,qBAAqB,CAAC;AACxF,UAAI,MAAM,eAAe,MAAM;AAAsB,eAAO,QAAQ,sBAAsB,CAAC;AAC3F,UAAI,MAAM,eAAe,QAAQ,CAAC;AAAG,eAAO,YAAY,CAAC;AACzD,aAAO;AAAA,IACR;AAEA,UAAM,cAAc,CAAC,GAAG,MAAM;AAC7B,YAAM,mBAAmB,CAAC,QAAQ;AACjC,YAAI,gBAAgB,CAAC,qBAAqB,YAAY,sBAAsB,WAAW;AACvF,eAAO,OAAO,KAAK,GAAG,EAAE,WAAW,KAAK,cAAc,OAAO,CAAC,MAAM,MAAM,OAAO,KAAK,GAAG,EAAE,CAAC,CAAC,EAAE,SAAS;AAAA,MACzG;AAEA,UAAI,EAAE,gBAAgB,OAAO;AAC5B,UAAE,IAAI,CAAC,QAAQ;AACd,cAAI,OAAO,KAAK,GAAG,EAAE,WAAW,KAAK,iBAAiB,CAAC;AAAG,mBAAO,IAAI,OAAO,KAAK,GAAG,EAAE,CAAC,CAAC;AAExF,iBAAO;AAAA,QACR,CAAC;AAAA,MACF;AACA,UAAI,EAAE,gBAAgB,QAAQ;AAC7B,YAAI,OAAO,KAAK,CAAC,EAAE,WAAW,KAAK,iBAAiB,CAAC;AAAG,iBAAO,EAAE,OAAO,KAAK,CAAC,EAAE,CAAC,CAAC;AAAA,MACnF;AAIA,aAAO;AAAA,IACR;AAEA,QAAI,eAAe,KAAK,UAAU,KAAK,MAAM;AAC7C,WAAO,KAAK,MAAM,cAAc,WAAW;AAAA,EAC5C;AAEA,QAAM,UAAU;AAAA,IACf,KAAK;AAAA,IACL,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,KAAK;AAAA,IACL,MAAM;AAAA,IACN,SAAS;AAAA,IACT,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK,MAAM;AAAA,IACX,sBAAsB;AAAA,IACtB,qBAAqB;AAAA,IACrB,WAAW;AAAA,IACX,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,WAAW;AAAA,EACZ;AAEA,MAAI,OAAO,KAAK,OAAO,EAAE,SAAS,IAAI;AAAG,WAAO,QAAQ,IAAI,EAAE,KAAK;AAAA;AAC9D,UAAM,IAAI,MAAM,UAAU,IAAI,+BAA+B;AACnE;AAEA,QAAQ,YAAY;;;AD/Kb,IAAM,gBAAN,MAAoB;AAAA,EAG1B,YAAY,kBAAqC;AAChD,QAAI,OAAO,qBAAqB,YAAY,OAAO,KAAK,gBAAgB,EAAE,WAAW;AACpF,YAAM,IAAI,MAAM,iCAAiC,OAAO,gBAAgB,EAAE;AAC3E,QAAI,CAAC,MAAM,QAAQ,iBAAiB,gBAAgB,KAAK,iBAAiB,iBAAiB,WAAW;AACrG,YAAM,IAAI,MAAM,8BAA8B;AAC/C,SAAK,QAAQ,KAAK,cAAc,iBAAiB,gBAAgB;AAAA,EAClE;AAAA,EAEA,iBAAiB,MAAc;AAC9B,QAAI,YAAY,CAAC,YAAY,SAAS;AACtC,QAAI,UAAU,IAAI,CAAC,aAAa,KAAK,SAAS,QAAQ,CAAC,EAAE,SAAS,IAAI;AAAG,aAAO;AAChF,UAAM,IAAI,MAAM,8CAA8C;AAAA,EAC/D;AAAA,EAEA,cAAc,OAAiB;AAC9B,WAAO,MAAM,IAAI,CAAC,SAAS,KAAK,iBAAiB,KAAK,YAAY,CAAC,CAAC;AAAA,EACrE;AAAA,EAEA,IAAI,OAAO;AACV,WAAO,KAAK,MAAM,KAAK,MAAM,KAAK,OAAO,IAAI,KAAK,MAAM,MAAM,CAAC;AAAA,EAChE;AAAA,EAEA,IAAI,MAAM;AACT,WAAO,KAAK;AAAA,EACb;AAAA,EAEM,gBAAgB,cAAsB;AAAA;AAC3C,YAAM,EAAE,KAAK,IAAI,MAAM,MAAM,KAAK,GAAG,KAAK,IAAI,+BAA+B,YAAY,GAAG;AAC5F,aAAO,YAAY,KAAK,OAAO,QAAQ;AAAA,IACxC;AAAA;AAAA,EAEM,YAAY,UAAkB,UAAkB;AAAA;AACrD,UAAI,OAAO,QAAQ,QAAQ,IAAI,QAAQ;AACvC,YAAM,MAAM,GAAG,KAAK,IAAI,qBAAqB,IAAI;AACjD,YAAM,EAAE,KAAK,IAAI,MAAM,MAAM,KAAK,GAAG;AACrC,YAAM,SAAS,KAAK,OAAO;AAC3B,UAAI,UAAU,YAAY,MAAM;AAChC,aAAO;AAAA,IACR;AAAA;AAAA,EAEM,mBAAmB,cAAc;AAAA;AACtC,YAAM,EAAE,KAAK,IAAI,MAAM,MAAM,KAAK,GAAG,KAAK,IAAI,uCAAuC,YAAY,GAAG;AACpG,aAAO,KAAK,MAAM,YAAY,KAAK,OAAO,QAAQ,CAAW;AAAA,IAC9D;AAAA;AAAA,EAEM,qBAAqB,cAAc;AAAA;AACxC,YAAM,EAAE,KAAK,IAAI,MAAM,MAAM,KAAK,GAAG,KAAK,IAAI,oCAAoC,YAAY,GAAG;AACjG,aAAO,KAAK,MAAM,YAAY,KAAK,OAAO,QAAQ,CAAW;AAAA,IAC9D;AAAA;AAAA,EAEM,aAAa;AAAA;AAClB,YAAM,EAAE,KAAK,IAAI,MAAM,MAAM,KAAK,GAAG,KAAK,IAAI,2BAA2B;AACzE,aAAO,KAAK,MAAM,YAAY,KAAK,OAAO,QAAQ,CAAW;AAAA,IAC9D;AAAA;AAAA,EAEM,mBAAmB,IAAY;AAAA;AACpC,UAAI,aAAa,MAAM,KAAK,YAAY,YAAY,YAAY,EAAE,EAAE;AACpE,UAAI,CAAC;AAAY,eAAO,QAAQ,aAAa,CAAC;AAC9C,UAAI;AAAY,eAAO,QAAQ,aAAa,UAAU;AACtD,aAAO,QAAQ,aAAa,WAAW,SAAS,CAAC;AAAA,IAClD;AAAA;AAAA,EAEM,eAAe,cAAc;AAAA;AAClC,YAAM,WAAW,MAAM,KAAK,gBAAgB,YAAY;AACxD,UAAI;AAAU,eAAO;AACrB,aAAO;AAAA,IACR;AAAA;AAAA,EAEM,YAAY,IAA4C;AAAA;AAC7D,YAAM,WAAW,qBAAqB,EAAE;AACxC,YAAM,MAAM,GAAG,KAAK,IAAI,4BAA4B,QAAQ;AAC5D,YAAM,EAAE,KAAK,IAAI,MAAM,MAAM,IAAI,GAAG;AACpC,YAAM,EAAE,UAAU,YAAY,KAAK,IAAI,KAAK;AAC5C,YAAM,cAAc,WAAW,OAAO,UAAU,WAAW,IAAI,IAAI;AACnE,YAAM,QAAQ,SAAS,SAAS;AAChC,YAAM,UAAU,WAAW,SAAS;AACpC,aAAO,EAAE,SAAS,SAAS,SAAS,MAAM,aAAa,KAAK;AAAA,IAC7D;AAAA;AAAA,EAEM,SAAS,IAAY;AAAA;AAC1B,YAAM,OAAO,qCAAqC,EAAE;AACpD,YAAM,MAAM,GAAG,KAAK,IAAI,GAAG,IAAI;AAC/B,YAAM,EAAE,KAAK,IAAI,MAAM,MAAM,KAAK,GAAG;AACrC,YAAM,QAAQ,KAAK,OAAO,SAAS;AACnC,UAAI,UAAU;AAAQ,eAAO;AAC7B,YAAM,UAAU,UAAU,KAAK;AAC/B,aAAO;AAAA,IACR;AAAA;AAAA,EAEA,eAAe,MAAc;AAC5B,WAAO,MAAM,IAAI,GAAG,KAAK,IAAI,eAAe,IAAI,GAAG;AAAA,EACpD;AAAA,EAEA,cAAc;AACb,WAAO,MAAM,IAAI,GAAG,KAAK,IAAI,SAAS;AAAA,EACvC;AAAA,EAEM,iBAAiB;AAAA;AACtB,aAAO,MAAM,IAAI,GAAG,KAAK,IAAI,QAAQ;AAAA,IACtC;AAAA;AACD;;;AEvGO,IAAM,qBAAN,MAAyB;AAAA,EAkB/B,YAAY,iBAAoC,QAAkB;AAblE,kBAAiB,CAAC;AAIlB,6BAA6B;AAC7B,wBAAqC,EAAE,QAAQ,CAAC,EAAE;AAClD,yBAAwB,CAAC;AAYxB,QAAI,OAAO,WAAW,YAAY,OAAO,KAAK,MAAM,EAAE,WAAW;AAAG,YAAM,IAAI,MAAM,yBAAyB;AAC7G,QAAI,OAAO,OAAO,aAAa,YAAY,CAAC,iBAAiB,KAAK,OAAO,QAAQ;AAChF,YAAM,IAAI,MAAM,+CAA+C;AAChE,QAAI,OAAO,OAAO,iBAAiB,YAAY,OAAO,aAAa,KAAK,MAAM;AAC7E,YAAM,IAAI,MAAM,uCAAuC;AACxD,QAAI,OAAO,OAAO,eAAe,YAAY,OAAO,WAAW,KAAK,MAAM;AAAI,YAAM,IAAI,MAAM,gCAAgC;AAC9H,QAAI,OAAO,OAAO,eAAe,YAAY,CAAC,OAAO,UAAU,OAAO,UAAU;AAC/E,YAAM,IAAI,MAAM,uCAAuC;AACxD,QAAI,OAAO,OAAO;AACjB,UAAI,CAAC,OAAO,UAAU,OAAO,KAAK;AACjC,cAAM,IAAI,MAAM,mDAAmD,OAAO,OAAO,KAAK,YAAY;AACnG,WAAK,QAAQ,OAAO;AAAA,IACrB;AAMA,SAAK,SAAS,OAAO;AACrB,SAAK,gBAAgB,IAAI,cAAc,eAAe;AACtD,SAAK,WAAW,OAAO;AACvB,SAAK,SAAS,OAAO;AACrB,QAAI,OAAO,OAAO,WAAW,UAAU;AACtC,WAAK,SAAS,OAAO;AAAA,IACtB;AACA,SAAK,aAAa,OAAO;AACzB,SAAK,WAAW,gBAAgB;AAEhC,SAAK,UAAU;AAAA,MACd,QAAQ,OAAO;AAAA,MACf,UAAU,OAAO;AAAA,MACjB,UAAU,OAAO;AAAA,MACjB,QAAQ,OAAO;AAAA,MACf,iBAAiB,OAAO;AAAA,MACxB,UAAU,OAAO;AAAA,MACjB,OAAO,OAAO,QAAQ,OAAO,QAAQ;AAAA;AAAA,IACtC;AAAA,EACD;AAAA,EAEQ,KAAK,IAAY,eAAgC;AACxD,UAAM,eAAe,OAAO,KAAK,cAAc,QAAQ;AACvD,UAAM,cAAc,IAAI,WAAW,YAAY;AAC/C,WAAc,KAAK,IAAI,WAAW;AAAA,EACnC;AAAA,EAEa,KAAK,IAAqC;AAAA;AACtD,UAAI;AAEH,YAAI,CAAC,KAAK,QAAQ,OAAO;AACxB,eAAK,QAAQ,QAAQ,MAAM,KAAK,cAAc,SAAS,KAAK,MAAM;AAAA,QACnE;AACA,aAAK,gBAAgB,YAAY,KAAK,OAAO;AAE7C,cAAM,YAAY,KAAK,KAAK,IAAI,KAAK,aAAa;AAElD,cAAM,KAAK,gBAAgB,WAAW,KAAK,aAAa;AAExD,YAAI,WAAW,MAAM,KAAK,cAAc,YAAY,EAAE;AACtD,eAAO;AAAA,MACR,SAAS,GAAG;AACX,eAAO;AAAA,UACN,SAAS;AAAA,UACT,OAAO;AAAA,QACR;AAAA,MACD;AAAA,IACD;AAAA;AACD;;;AC3FO,IAAM,WAAN,MAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBlB,YAAY,MAAM,QAAW;AACzB,SAAK,mBAAmB;AACxB,SAAK,WAAW;AAChB,SAAK,gBAAgB;AAErB,SAAK,UAAW,uBAAM;AAClB,UAAI,UAAU,CAAC;AACf,UAAI,aAAa;AACjB,UAAI,UAAU,CAAC;AAEf,YAAM,SAAS,CAAC,QAAQ;AACpB,gBAAQ,KAAK,GAAG;AAChB,sBAAc;AAAA,MAClB;AACA,YAAM,YAAY,CAAC,aAAa;AAC5B,gBAAQ,OAAO,UAAU,CAAC;AAC1B,sBAAc;AAAA,MAClB;AACA,YAAM,YAAY,MAAM;AACpB,kBAAU,CAAC;AACX,sBAAc;AAAA,MAClB;AACA,YAAM,YAAY,MAAM,QAAQ;AAChC,YAAM,gBAAgB,MAAM;AACxB,kBAAU,CAAC;AACX,gBAAQ,QAAQ,aAAW;AACvB,cAAI,YAAmB,cAAc,EAAC,IAAI,QAAQ,IAAI,aAAa,KAAI,CAAC;AACxE,sBAAY,kCAAI,YAAc;AAC9B,iBAAO,UAAU;AACjB,kBAAQ,KAAK,SAAS;AAAA,QAC1B,CAAC;AAAA,MACL;AACA,YAAM,iBAAiB,CAAC,UAAU,OAAO,WAAc;AACnD,eAAO,KAAK,UAAU;AAAA,UAClB,MAAc,cAAc,UAAU,EAAC,SAAS,WAAW,kBAAkB,QAAO,CAAC;AAAA,UACrF,GAAG,CAAC,OAAO,KAAa,eAAe,cAAc,IAAI;AAAA,QAC7D,CAAC;AAAA,MACL;AACA,YAAM,kBAAkB,CAAC,UAAU,SAAS;AACxC,YAAI,YAAoB,cAAc,UAAU,IAAI;AACpD,YAAI,WAAW;AACX,cAAI,CAAC,MAAM,QAAQ,UAAU,OAAO,GAAG;AACnC,kBAAM,IAAI,MAAM,4CAA4C;AAAA,UAChE;AACA,oBAAU,QAAQ,QAAQ,aAAW;AACjC,gBAAI,OAAO,QAAQ,OAAO,YAAY,QAAQ,GAAG,KAAK,MAAM,IAAI;AAC5D,oBAAM,IAAI,MAAM,0DAA0D;AAAA,YAC9E;AAAA,UACJ,CAAC;AACD,oBAAU,QAAQ,QAAQ,aAAW,OAAO,OAAO,CAAC;AACpD,qBAAW,UAAU,UAAU;AAAA,QACnC,OAAO;AACH,gBAAM,IAAI,MAAM,8BAA8B;AAAA,QAClD;AAAA,MACJ;AAEA,aAAO;AAAA,QACH,YAAY,MAAM;AAAA,QAClB,WAAW,CAAC,OAAO,QAAQ,KAAK,YAAU,OAAO,OAAO,EAAE;AAAA,QAC1D;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAAA,IACJ,GAAG;AAEH,QAAI,KAAI;AACJ,UAAI,IAAI;AAAK,aAAK,OAAO,IAAI,GAAG;AAChC,UAAI,IAAI;AAAS,aAAK,QAAQ,IAAI,OAAO;AACzC,UAAI,IAAI;AAAc,aAAK,gBAAgB,IAAI,YAAY;AAAA,IAC/D;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,QAAQ,SAAQ;AACZ,QAAI,CAAC,MAAM,QAAQ,OAAO,GAAG;AACzB,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC/C;AACA,YAAQ,QAAQ,SAAO,KAAK,OAAO,GAAG,CAAC;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,OAAO,SAAQ;AACX,QAAI,OAAO,YAAY,YAAY,OAAO,KAAK,OAAO,EAAE,WAAW,GAAG;AAClE,YAAM,IAAI,MAAM,sCAAsC;AAAA,IAC1D;AACA,QAAI,OAAO,QAAQ,OAAO,YAAY,QAAQ,GAAG,KAAK,MAAM,IAAI;AAC5D,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAClE;AACA,QAAI,OAAO,QAAQ,OAAO,YAAY,QAAQ,GAAG,KAAK,MAAM,IAAI;AAC5D,aAAO,QAAQ;AAAA,IACnB;AACA,SAAK,QAAQ,OAAO,OAAO;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,cAAa;AACzB,QAAI,OAAO,iBAAiB;AAAU,qBAAe,KAAK,MAAM,YAAY;AAC5E,QAAI,OAAO,KAAK,qBAAqB,cAAc,KAAK,iBAAiB,YAAY,GAAG;AACpF,WAAK,gBAAgB;AAAA,IACzB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,eAAe,QAAU;AACrC,QAAI,CAAC,KAAK,iBAAiB,CAAC;AAAc,YAAM,IAAI,MAAM,yBAAyB;AAEnF,QAAI,cAAe;AACf,UAAI,OAAO,iBAAiB;AAAW,uBAAe,KAAK,MAAM,YAAY;AAAA,IACjF;AACK,qBAAe,KAAK;AAEzB,QAAI,aAAa;AAAG,aAAe,eAAe,cAAc,aAAa,CAAC;AAAA;AACzE,aAAO;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,UAAS;AACf,QAAI,CAAC,OAAO,UAAU,QAAQ,GAAG;AAC7B,YAAM,IAAI,MAAM,+BAA+B;AAAA,IACnD;AACA,QAAI,KAAK,QAAQ,UAAU,MAAM;AAAG;AACpC,QAAI,WAAW,KAAK,YAAY,KAAK,QAAQ,UAAU;AAAG,YAAM,IAAI,MAAM,yBAAyB;AACnG,SAAK,QAAQ,UAAU,QAAQ;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAIA,YAAW;AACP,SAAK,QAAQ,UAAU;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAAU;AACV,WAAO,KAAK,QAAQ,WAAW;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU,IAAI;AACV,WAAO,KAAK,QAAQ,UAAU,EAAE;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,iBAAiB,cAAa;AAC1B,QAAI,OAAO,iBAAiB,YAAY,OAAO,KAAK,YAAY,EAAE,WAAW,GAAG;AAC5E,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAChE;AACA,QAAG;AACC,UAAI,gBAAgB,KAAK,MAAM,aAAa,IAAI;AAC/C,UAAI,CAAC,cAAc,MAAM,CAAC,cAAc,MAAM,CAAC,cAAc,GAAE;AAC5D,cAAM,IAAI,MAAM,oCAAoC;AAAA,MACxD;AAAA,IACJ,SAAS,GAAG;AACR,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACxD;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,eAAe,UAAU,OAAO,QAAW;AACvC,QAAI,OAAO,aAAa,YAAY,SAAS,KAAK,MAAM,IAAI;AACxD,YAAM,IAAI,MAAM,sCAAsC;AAAA,IAC1D;AACA,QAAI,SAAS,OAAO,SAAS,YAAY,KAAK,KAAK,MAAM,KAAK;AAC1D,YAAM,IAAI,MAAM,kCAAkC;AAAA,IACtD;AACA,WAAO,KAAK,QAAQ,eAAe,UAAU,IAAI;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,UAAU,eAAe,QAAU;AAC/C,QAAI;AAAc,WAAK,gBAAgB,YAAY;AACnD,QAAI,CAAC,KAAK;AAAe,YAAM,IAAI,MAAO,6BAA6B;AACvE,QAAG;AACC,WAAK,QAAQ,gBAAgB,UAAU,KAAK,cAAc,IAAI;AAAA,IAClE,SAAQ,GAAE;AACN,YAAM,IAAI,MAAM,8BAA8B;AAAA,IAClD;AAAA,EACJ;AACJ;;;AC3OA,SAAS,UAAAC,eAAc;AAEvB,WAAW,SAASA;","names":["validateMnemonic","validateMnemonic","isArray","isObject","Buffer"]}